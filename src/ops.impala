

fn @generic_call(out : &mut[f64], sub : &GridSubset, conn : &GridConnectivity,
                 vals : &[f64], wghts : &[f64], level_count : u32, trg_count : i32) -> () {
  let connectivity = connectivity_to_device(conn);
  let subset = subset_to_device(sub);
  let values = values_to_device(sub.grid.counts(EDGE) * level_count, vals);
  let weights = values_to_device(sub.grid.counts(CELL) * sub.grid.connectivities(CELL)(EDGE).trg_count, wghts);

  let output_size = sub.grid.counts(CELL) * level_count;
  let output = output_of_device(output_size, out);

  for output_idx in outer_loop(0, subset.count()) {
    let entity_idx = subset.indices(output_idx);

    for level_idx in inner_loop(0, level_count as i32) {
      let mut result = 0.0 as f64;
      for connect_idx in inner_loop(0, trg_count) {
        let flat_connect_idx = entity_idx * (trg_count as u32) + connect_idx as u32;
        let flat_values_idx  = connectivity.matrix(flat_connect_idx) * level_count + (level_idx as u32);

        result += values.read(flat_values_idx as u32) * weights.read(flat_connect_idx as u32);
      }
      output.write((output_idx as u32) * (level_count as u32) + (level_idx as u32), result);
    }
  }

  output_to_host(output_size, output, out);
  ()
}

extern
fn calc_wsum_generic(out : &mut[f64], sub : &GridSubset, conn : &GridConnectivity,
                      vals : &[f64], wghts : &[f64], level_count : u32) -> () {
  @@generic_call(out, sub, conn, vals, wghts, level_count, conn.trg_count as i32)
}


extern
fn calc_wsum_triangle(out : &mut[f64], sub : &GridSubset, conn : &GridConnectivity,
                      vals : &[f64], wghts : &[f64], level_count : u32) -> () {
  @@generic_call(out, sub, conn, vals, wghts, level_count, 3)
}
